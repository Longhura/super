--[[
    Script: LookAt & Follow GUI
    M√¥ t·∫£: Hi·ªÉn th·ªã giao di·ªán ƒë·ªÉ ch·ªçn ng∆∞·ªùi ch∆°i, nh√¨n v√†o h·ªç (v√†o b·ªô ph·∫≠n ho·∫∑c t·ª´ sau l∆∞ng),
           t·ª± ƒë·ªông d·ªãch chuy·ªÉn theo sau l∆∞ng, v√† c√°c ch·ª©c nƒÉng ph·ª• tr·ª£ kh√°c.
    Ng√†y c·∫≠p nh·∫≠t: 2025-04-06
]]

-- Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Local Player & Camera
local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- GUI setup
local ScreenGui = Instance.new("ScreenGui", Player:WaitForChild("PlayerGui"))
ScreenGui.Name = "LookFollowGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Frame Configuration
local frameWidth = 260
local frameHeight = 380 -- TƒÉng chi·ªÅu cao ƒë·ªÉ ch·ª©a th√™m n√∫t
local framePosX = 0.02
local framePosY = 0.15 -- N√¢ng l√™n m·ªôt ch√∫t

local Frame = Instance.new("Frame", ScreenGui)
Frame.Size = UDim2.new(0, frameWidth, 0, frameHeight)
Frame.Position = UDim2.new(framePosX, 0, framePosY, 0)
Frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Frame.Active = true
Frame.Draggable = true
Frame.BorderSizePixel = 0
Frame.ClipsDescendants = true
Instance.new("UICorner", Frame).CornerRadius = UDim.new(0, 8)

local UIStroke = Instance.new("UIStroke", Frame)
UIStroke.Thickness = 2
UIStroke.Color = Color3.fromRGB(255, 0, 0)

-- Title Bar Elements
local titleBarHeight = 30
local controlButtonSize = 24
local controlButtonPadding = 5

local Title = Instance.new("TextLabel", Frame)
Title.Size = UDim2.new(1, -(controlButtonSize * 2 + controlButtonPadding * 3), 0, titleBarHeight)
Title.Position = UDim2.new(0, controlButtonPadding, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Nh√¨n & Theo D√µi" -- ƒê·ªïi t√™n
Title.Font = Enum.Font.GothamBold
Title.TextSize = 15
Title.TextColor3 = Color3.new(1,1,1)
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.TextYAlignment = Enum.TextYAlignment.Center

local CloseButton = Instance.new("TextButton", Frame)
CloseButton.Size = UDim2.new(0, controlButtonSize, 0, controlButtonSize)
CloseButton.Position = UDim2.new(1, -(controlButtonSize + controlButtonPadding), 0, (titleBarHeight - controlButtonSize) / 2)
CloseButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50); CloseButton.Text = "‚úï"; CloseButton.TextColor3 = Color3.new(1,1,1); CloseButton.Font = Enum.Font.GothamBold; CloseButton.TextSize = 14
Instance.new("UICorner", CloseButton).CornerRadius = UDim.new(0, 4)

local MinimizeButton = Instance.new("TextButton", Frame)
MinimizeButton.Size = UDim2.new(0, controlButtonSize, 0, controlButtonSize); MinimizeButton.Position = UDim2.new(1, -(controlButtonSize * 2 + controlButtonPadding * 2), 0, (titleBarHeight - controlButtonSize) / 2)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100); MinimizeButton.Text = "-"; MinimizeButton.TextColor3 = Color3.new(1,1,1); MinimizeButton.Font = Enum.Font.GothamBold; MinimizeButton.TextSize = 18
Instance.new("UICorner", MinimizeButton).CornerRadius = UDim.new(0, 4)

-- State Variables
local looking = false -- Ch√≠nh: B·∫≠t/t·∫Øt nh√¨n chung
local lookingFromBehind = false -- Ph·ª•: B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô nh√¨n t·ª´ sau l∆∞ng
local followingBehind = false -- Ph·ª•: B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô theo sau l∆∞ng li√™n t·ª•c
local bodyParts = {"Head", "UpperTorso", "HumanoidRootPart", "LeftFoot", "RightFoot"}
local partIndex = 1
local currentTarget = nil
local buttons = {} -- Dictionary: [Player] = Button
local targetHumanoidConnection = nil
local listButtonYOffset = 3
local followDistance = 4 -- Kho·∫£ng c√°ch theo sau l∆∞ng
local lookBehindDistance = 8 -- Kho·∫£ng c√°ch nh√¨n t·ª´ sau l∆∞ng
local lookBehindHeightOffset = 3 -- ƒê·ªô cao camera khi nh√¨n t·ª´ sau l∆∞ng

-- Button Colors & Text Constants
local COLOR_ON = Color3.fromRGB(0, 170, 0)
local COLOR_OFF = Color3.fromRGB(170, 0, 0)
local COLOR_NEUTRAL = Color3.fromRGB(80, 80, 80)
local COLOR_ACTION = Color3.fromRGB(60, 60, 200)
local COLOR_WARN = Color3.fromRGB(255, 165, 0)
local COLOR_RIP = Color3.fromRGB(100, 100, 100)

local TEXT_LOOK_ON = "‚úÖ B·∫≠t Nh√¨n"
local TEXT_LOOK_OFF = "‚ùé T·∫Øt Nh√¨n"
local TEXT_LOOK_RIP = "üíÄ Rip"
local TEXT_LOOKBEHIND_ON = "‚úÖ Nh√¨n T·ª´ Sau"
local TEXT_LOOKBEHIND_OFF = "‚ùé Nh√¨n T·ª´ Sau"
local TEXT_FOLLOW_ON = "‚úÖ Theo Sau L∆∞ng"
local TEXT_FOLLOW_OFF = "‚ùé Theo Sau L∆∞ng"

-- Function Buttons
local funcButtonHeight = 28
local funcButtonSpacing = 5
local currentY = titleBarHeight + funcButtonSpacing * 2

local function CreateFunctionButton(text, color, yPos)
	local btn = Instance.new("TextButton", Frame)
	btn.Size = UDim2.new(1, -controlButtonPadding * 2, 0, funcButtonHeight)
	btn.Position = UDim2.new(0, controlButtonPadding, 0, yPos)
	btn.BackgroundColor3 = color; btn.Text = text; btn.TextColor3 = Color3.new(1,1,1); btn.Font = Enum.Font.Gotham; btn.TextSize = 14
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 5)
	return btn
end

-- Create Buttons (Th·ª© t·ª± quan tr·ªçng cho layout)
local toggleButton = CreateFunctionButton(TEXT_LOOK_OFF, COLOR_OFF, currentY); currentY += funcButtonHeight + funcButtonSpacing -- N√∫t nh√¨n ch√≠nh
local lookBehindButton = CreateFunctionButton(TEXT_LOOKBEHIND_OFF, COLOR_NEUTRAL, currentY); currentY += funcButtonHeight + funcButtonSpacing -- N√∫t ch·∫ø ƒë·ªô nh√¨n t·ª´ sau
local partButton = CreateFunctionButton("Nh√¨n: " .. bodyParts[partIndex], COLOR_NEUTRAL, currentY); currentY += funcButtonHeight + funcButtonSpacing -- N√∫t ch·ªçn b·ªô ph·∫≠n
local followButton = CreateFunctionButton(TEXT_FOLLOW_OFF, COLOR_ACTION, currentY); currentY += funcButtonHeight + funcButtonSpacing -- N√∫t theo sau li√™n t·ª•c
local teleportButton = CreateFunctionButton("üö∂ D·ªãch Chuy·ªÉn Sau L∆∞ng (1 l·∫ßn)", COLOR_ACTION, currentY); currentY += funcButtonHeight + funcButtonSpacing -- N√∫t d·ªãch chuy·ªÉn 1 l·∫ßn
local nearestButton = CreateFunctionButton("üìç Ch·ªçn G·∫ßn Nh·∫•t", COLOR_WARN, currentY); currentY += funcButtonHeight + funcButtonSpacing -- N√∫t ch·ªçn g·∫ßn nh·∫•t
local reloadButton = CreateFunctionButton("T·∫£i l·∫°i danh s√°ch", COLOR_NEUTRAL, currentY); currentY += funcButtonHeight + funcButtonSpacing -- N√∫t t·∫£i l·∫°i list

-- Player List Scrolling Frame
local listHeight = frameHeight - currentY - controlButtonPadding -- T√≠nh chi·ªÅu cao c√≤n l·∫°i
local playerList = Instance.new("ScrollingFrame", Frame)
playerList.Position = UDim2.new(0, controlButtonPadding, 0, currentY)
playerList.Size = UDim2.new(1, -controlButtonPadding * 2, 0, listHeight)
playerList.BackgroundColor3 = Color3.fromRGB(50, 50, 50); playerList.ScrollBarThickness = 6; playerList.CanvasSize = UDim2.new(0, 0, 0, 0); playerList.BorderSizePixel = 0
Instance.new("UICorner", playerList).CornerRadius = UDim.new(0, 5)

-- Minimized Icon
local MinimizedIcon = Instance.new("TextButton", ScreenGui)
MinimizedIcon.Size = UDim2.new(0, 80, 0, 25); MinimizedIcon.Position = UDim2.new(0, 5, 1, -30) -- G√≥c d∆∞·ªõi tr√°i
MinimizedIcon.Text = "M·ªü Nh√¨n"; MinimizedIcon.BackgroundColor3 = Color3.fromRGB(60, 60, 60); MinimizedIcon.TextColor3 = Color3.new(1,1,1); MinimizedIcon.Font = Enum.Font.Gotham; MinimizedIcon.TextSize = 12
MinimizedIcon.Visible = false; MinimizedIcon.Active = true; MinimizedIcon.Draggable = true
Instance.new("UICorner", MinimizedIcon).CornerRadius = UDim.new(0, 4)

-- Rainbow Border Effect Coroutine
task.spawn(function()
	local colors = {
		Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 127, 0), Color3.fromRGB(255, 255, 0),
		Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 255, 255), Color3.fromRGB(0, 0, 255),
		Color3.fromRGB(139, 0, 255)
	}
	local i = 1
	while ScreenGui.Parent do
		if Frame.Visible then -- Ch·ªâ ch·∫°y tween khi frame hi·ªÉn th·ªã
			local color = colors[i]
			local tween = TweenService:Create(UIStroke, TweenInfo.new(0.4), {Color = color})
			tween:Play()
			tween.Completed:Wait()
			i = i % #colors + 1
		else
			task.wait(0.5) -- ƒê·ª£i khi frame ·∫©n
		end
	end
end)

-- Helper Functions
local function highlightSelectedButton(selectedPlayer)
    for player, btn in pairs(buttons) do
        if btn and btn.Parent then
            local isSelected = (player == selectedPlayer)
            btn.BackgroundColor3 = isSelected and Color3.fromRGB(120, 120, 120) or Color3.fromRGB(70, 70, 70)
            local stroke = btn:FindFirstChildOfClass("UIStroke")
            if stroke then stroke.Enabled = isSelected end
        end
    end
end

local function resetTargetStates()
    looking = false
    followingBehind = false
    lookingFromBehind = false
    currentTarget = nil

    toggleButton.Text = TEXT_LOOK_OFF
    toggleButton.BackgroundColor3 = COLOR_OFF
    followButton.Text = TEXT_FOLLOW_OFF
    followButton.BackgroundColor3 = COLOR_ACTION -- Reset v·ªÅ m√†u neutral/action
    lookBehindButton.Text = TEXT_LOOKBEHIND_OFF
    lookBehindButton.BackgroundColor3 = COLOR_NEUTRAL -- Reset v·ªÅ m√†u neutral

    highlightSelectedButton(nil)
    if targetHumanoidConnection then
        targetHumanoidConnection:Disconnect()
        targetHumanoidConnection = nil
    end
end

local function setTarget(player)
	if currentTarget == player then return end -- Kh√¥ng l√†m g√¨ n·∫øu ch·ªçn l·∫°i c√πng m·ª•c ti√™u

    -- Ng·∫Øt k·∫øt n·ªëi c≈© v√† reset tr·∫°ng th√°i li√™n quan ƒë·∫øn m·ª•c ti√™u c≈©
	if targetHumanoidConnection then targetHumanoidConnection:Disconnect(); targetHumanoidConnection = nil end
    -- Kh√¥ng reset looking, followingBehind, lookingFromBehind ·ªü ƒë√¢y, ch·ªâ reset khi m·ª•c ti√™u ch·∫øt/r·ªùi game

	currentTarget = player
    print("ƒê√£ ch·ªçn m·ª•c ti√™u:", player.Name)

	local char = player.Character
	local humanoid = char and char:FindFirstChildOfClass("Humanoid")

	if humanoid and humanoid.Health > 0 then -- Ch·ªâ k·∫øt n·ªëi n·∫øu m·ª•c ti√™u c√≤n s·ªëng
        -- Reset n√∫t toggle v·ªÅ tr·∫°ng th√°i ON/OFF d·ª±a tr√™n tr·∫°ng th√°i looking hi·ªán t·∫°i
        if toggleButton.Text == TEXT_LOOK_RIP then -- N·∫øu tr∆∞·ªõc ƒë√≥ l√† RIP, b·∫•m ch·ªçn ng∆∞·ªùi m·ªõi s·∫Ω t·ª± b·∫≠t nh√¨n
             looking = true
        end
        toggleButton.Text = looking and TEXT_LOOK_ON or TEXT_LOOK_OFF
        toggleButton.BackgroundColor3 = looking and COLOR_ON or COLOR_OFF

		targetHumanoidConnection = humanoid.Died:Connect(function()
			print(player.Name, "ƒë√£ ch·∫øt.")
			if currentTarget == player then -- Quan tr·ªçng: Ch·ªâ reset n·∫øu m·ª•c ti√™u ch·∫øt v·∫´n l√† m·ª•c ti√™u hi·ªán t·∫°i
                -- ƒê·∫∑t tr·∫°ng th√°i RIP cho n√∫t nh√¨n ch√≠nh
                toggleButton.Text = TEXT_LOOK_RIP
                toggleButton.BackgroundColor3 = COLOR_RIP
                -- T·∫Øt c√°c ch·∫ø ƒë·ªô ph·ª• v√† reset n√∫t c·ªßa ch√∫ng
                followingBehind = false
                lookingFromBehind = false
                followButton.Text = TEXT_FOLLOW_OFF; followButton.BackgroundColor3 = COLOR_ACTION
                lookBehindButton.Text = TEXT_LOOKBEHIND_OFF; lookBehindButton.BackgroundColor3 = COLOR_NEUTRAL
                -- Reset c√°c bi·∫øn kh√°c
				looking = false
				currentTarget = nil
				highlightSelectedButton(nil)
				if targetHumanoidConnection then targetHumanoidConnection:Disconnect(); targetHumanoidConnection = nil end
			end
		end)
	else
        -- N·∫øu kh√¥ng t√¨m th·∫•y humanoid ho·∫∑c ƒë√£ ch·∫øt, b√°o l·ªói v√† kh√¥ng ƒë·∫∑t l√†m m·ª•c ti√™u
         print("Kh√¥ng th·ªÉ ƒë·∫∑t m·ª•c ti√™u:", player.Name, "- Kh√¥ng t√¨m th·∫•y Humanoid ho·∫∑c ƒë√£ ch·∫øt.")
         currentTarget = nil -- Kh√¥ng ƒë·∫∑t m·ª•c ti√™u
         -- Kh√¥ng thay ƒë·ªïi tr·∫°ng th√°i looking/following/lookbehind ·ªü ƒë√¢y
	end
    highlightSelectedButton(currentTarget) -- Highlight ng∆∞·ªùi ch∆°i m·ªõi (ho·∫∑c nil n·∫øu kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c)
end

local function updateList()
    -- Clear old buttons
    for _, btn in pairs(buttons) do if btn and btn.Parent then btn:Destroy() end end
    buttons = {}

    local yPos = listButtonYOffset
    local canvasHeight = yPos
    local targetStillInGame = false

    -- Populate new buttons
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Player then
            local btn = Instance.new("TextButton", playerList)
            btn.Size = UDim2.new(1, -10, 0, 25); btn.Position = UDim2.new(0, 5, 0, yPos)
            btn.BackgroundColor3 = Color3.fromRGB(70, 70, 70); btn.Text = p.Name; btn.TextColor3 = Color3.new(1,1,1); btn.Font = Enum.Font.Gotham; btn.TextSize = 13
            Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4)
            local stroke = Instance.new("UIStroke", btn); stroke.Color = Color3.fromRGB(255, 255, 0); stroke.Thickness = 1; stroke.Enabled = false -- Stroke for highlight
            buttons[p] = btn
            btn.MouseButton1Click:Connect(function() setTarget(p) end)
            yPos += 25 + listButtonYOffset
            canvasHeight = yPos
            if currentTarget and p == currentTarget then targetStillInGame = true end
        end
    end
    playerList.CanvasSize = UDim2.new(0, 0, 0, math.max(canvasHeight, playerList.AbsoluteSize.Y))

    -- Handle if current target left
    if currentTarget and not targetStillInGame then
        print("M·ª•c ti√™u c≈©", currentTarget.Name, "ƒë√£ r·ªùi game.")
        resetTargetStates() -- Reset m·ªçi th·ª© li√™n quan ƒë·∫øn m·ª•c ti√™u
    end

    highlightSelectedButton(currentTarget) -- Highlight l·∫°i (c√≥ th·ªÉ l√† nil)
end

-- Button Event Connections
reloadButton.MouseButton1Click:Connect(updateList)

nearestButton.MouseButton1Click:Connect(function()
	local closestPlayer = nil; local shortestDistance = math.huge
	local myRoot = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return end
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= Player and p.Character then
            local targetRoot = p.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
			    local distance = (targetRoot.Position - myRoot.Position).Magnitude
			    if distance < shortestDistance then closestPlayer = p; shortestDistance = distance end
            end
		end
	end
	if closestPlayer then print("Ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t:", closestPlayer.Name); setTarget(closestPlayer)
    else print("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i n√†o kh√°c.") end
end)

-- Teleport Button (Single Use)
teleportButton.MouseButton1Click:Connect(function()
	if currentTarget and currentTarget.Character then
		local targetRoot = currentTarget.Character:FindFirstChild("HumanoidRootPart")
        local myRoot = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
		if targetRoot and myRoot and Player.Character.PrimaryPart then
            local targetLookVector = targetRoot.CFrame.LookVector
            local teleportPosition = targetRoot.Position - (targetLookVector * followDistance) + Vector3.new(0,0.1,0) -- D·ªãch chuy·ªÉn ra sau, c√°ch followDistance
            local newCFrame = CFrame.new(teleportPosition, targetRoot.Position) -- Nh√¨n v·ªÅ ph√≠a m·ª•c ti√™u sau khi d·ªãch chuy·ªÉn
            Player.Character:SetPrimaryPartCFrame(newCFrame)
            print("ƒê√£ d·ªãch chuy·ªÉn (1 l·∫ßn) ra sau l∆∞ng", currentTarget.Name)
        else print("Kh√¥ng th·ªÉ d·ªãch chuy·ªÉn (1 l·∫ßn): Thi·∫øu RootPart.") end
	else print("Kh√¥ng th·ªÉ d·ªãch chuy·ªÉn (1 l·∫ßn): Ch∆∞a ch·ªçn m·ª•c ti√™u.") end
end)

-- Toggle Look Button (Main)
toggleButton.MouseButton1Click:Connect(function()
    if toggleButton.Text == TEXT_LOOK_RIP then
        looking = true -- B·∫≠t l·∫°i tr·∫°ng th√°i nh√¨n
        toggleButton.Text = TEXT_LOOK_ON
	    toggleButton.BackgroundColor3 = COLOR_ON
        print("Ch·∫ø ƒë·ªô nh√¨n ƒë∆∞·ª£c b·∫≠t. H√£y ch·ªçn m·ª•c ti√™u.")
    else
	    looking = not looking
	    toggleButton.Text = looking and TEXT_LOOK_ON or TEXT_LOOK_OFF
	    toggleButton.BackgroundColor3 = looking and COLOR_ON or COLOR_OFF
        print("Ch·∫ø ƒë·ªô nh√¨n:", looking and "B·∫≠t" or "T·∫Øt")
        -- T·ª± ƒë·ªông t·∫Øt nh√¨n t·ª´ sau n·∫øu t·∫Øt nh√¨n ch√≠nh
        if not looking and lookingFromBehind then
            lookingFromBehind = false
            lookBehindButton.Text = TEXT_LOOKBEHIND_OFF
            lookBehindButton.BackgroundColor3 = COLOR_NEUTRAL
        end
    end
end)

-- Toggle Look From Behind Button
lookBehindButton.MouseButton1Click:Connect(function()
    lookingFromBehind = not lookingFromBehind
    lookBehindButton.Text = lookingFromBehind and TEXT_LOOKBEHIND_ON or TEXT_LOOKBEHIND_OFF
    lookBehindButton.BackgroundColor3 = lookingFromBehind and COLOR_ON or COLOR_NEUTRAL
    print("Ch·∫ø ƒë·ªô nh√¨n t·ª´ sau:", lookingFromBehind and "B·∫≠t" or "T·∫Øt")
    -- T·ª± ƒë·ªông b·∫≠t nh√¨n ch√≠nh n·∫øu b·∫≠t nh√¨n t·ª´ sau
    if lookingFromBehind and not looking then
        looking = true
        toggleButton.Text = TEXT_LOOK_ON
        toggleButton.BackgroundColor3 = COLOR_ON
        print("Ch·∫ø ƒë·ªô nh√¨n ch√≠nh ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông b·∫≠t.")
    end
    -- T·∫Øt ch·ªçn b·ªô ph·∫≠n n·∫øu b·∫≠t nh√¨n t·ª´ sau (ho·∫∑c ng∆∞·ª£c l·∫°i) -> Kh√¥ng c·∫ßn, ch·ªâ c·∫ßn ∆∞u ti√™n trong RenderStep
    partButton.BackgroundColor3 = lookingFromBehind and COLOR_OFF or COLOR_NEUTRAL -- ƒê·ªïi m√†u n√∫t part ƒë·ªÉ b√°o hi·ªáu b·ªã v√¥ hi·ªáu h√≥a
end)

-- Cycle Body Part Button
partButton.MouseButton1Click:Connect(function()
    if lookingFromBehind then
        print("ƒêang ·ªü ch·∫ø ƒë·ªô nh√¨n t·ª´ sau, kh√¥ng th·ªÉ ƒë·ªïi b·ªô ph·∫≠n.")
        return -- Kh√¥ng cho ƒë·ªïi b·ªô ph·∫≠n khi ƒëang nh√¨n t·ª´ sau
    end
	partIndex = (partIndex % #bodyParts) + 1
	partButton.Text = "Nh√¨n: " .. bodyParts[partIndex]
    print("Chuy·ªÉn sang nh√¨n:", bodyParts[partIndex])
end)

-- Toggle Follow Behind Button
followButton.MouseButton1Click:Connect(function()
    followingBehind = not followingBehind
    followButton.Text = followingBehind and TEXT_FOLLOW_ON or TEXT_FOLLOW_OFF
    followButton.BackgroundColor3 = followingBehind and COLOR_ON or COLOR_ACTION
    print("Ch·∫ø ƒë·ªô theo sau l∆∞ng:", followingBehind and "B·∫≠t" or "T·∫Øt")
end)

-- Minimize/Maximize Buttons
MinimizeButton.MouseButton1Click:Connect(function() Frame.Visible = false; MinimizedIcon.Visible = true end)
MinimizedIcon.MouseButton1Click:Connect(function() Frame.Visible = true; MinimizedIcon.Visible = false end)

-- Close Button
CloseButton.MouseButton1Click:Connect(function() resetTargetStates(); ScreenGui:Destroy() end)

-- Core Logic Loop (RenderStep for Camera, Heartbeat potentially better for Physics/Follow)
local function CoreLoop(dt) -- dt is delta time, useful for smoothing if needed
    if not Player.Character or not Player.Character.PrimaryPart then return end -- Tho√°t n·∫øu ng∆∞·ªùi ch∆°i ch∆∞a spawn ho√†n ch·ªânh

    local myRoot = Player.Character.PrimaryPart
    local targetChar = currentTarget and currentTarget.Character
    local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")

    -- === Follow Logic ===
    if followingBehind and targetRoot and myRoot and currentTarget and toggleButton.Text ~= TEXT_LOOK_RIP then -- Ch·ªâ follow khi m·ª•c ti√™u h·ª£p l·ªá v√† kh√¥ng RIP
        local targetLookVector = targetRoot.CFrame.LookVector
        -- T√≠nh v·ªã tr√≠ mong mu·ªën sau l∆∞ng, gi·ªØ nguy√™n h∆∞·ªõng nh√¨n hi·ªán t·∫°i c·ªßa ng∆∞·ªùi ch∆°i
        local desiredPos = targetRoot.Position - (targetLookVector * followDistance) + Vector3.new(0,0.1,0)
        local currentPos = myRoot.Position
        local currentLookVector = myRoot.CFrame.LookVector

        -- Ch·ªâ d·ªãch chuy·ªÉn n·∫øu kho·∫£ng c√°ch ƒë·ªß l·ªõn ƒë·ªÉ tr√°nh rung l·∫Øc
        if (desiredPos - currentPos).Magnitude > 0.5 then
            -- Gi·ªØ h∆∞·ªõng nh√¨n hi·ªán t·∫°i c·ªßa ng∆∞·ªùi ch∆°i khi d·ªãch chuy·ªÉn
            Player.Character:SetPrimaryPartCFrame(CFrame.new(desiredPos) * CFrame.new(Vector3.zero, currentLookVector).Rotation)
            -- Ho·∫∑c n·∫øu mu·ªën lu√¥n nh√¨n v·ªÅ m·ª•c ti√™u khi follow:
            -- Player.Character:SetPrimaryPartCFrame(CFrame.new(desiredPos, targetRoot.Position))
        end
    end

    -- === Camera Logic ===
    if looking and targetRoot and currentTarget and toggleButton.Text ~= TEXT_LOOK_RIP then -- Ch·ªâ nh√¨n khi m·ª•c ti√™u h·ª£p l·ªá v√† kh√¥ng RIP
        local camera = workspace.CurrentCamera
        local lookFrom = camera.CFrame.Position
        local lookAt

        if lookingFromBehind then
            -- T√≠nh to√°n v·ªã tr√≠ camera sau l∆∞ng m·ª•c ti√™u
            local targetLook = targetRoot.CFrame.LookVector
            local targetPos = targetRoot.Position
            local cameraPos = targetPos - (targetLook * lookBehindDistance) + Vector3.new(0, lookBehindHeightOffset, 0)
            lookAt = targetPos + Vector3.new(0, 1, 0) -- Nh√¨n v√†o ph·∫ßn th√¢n tr√™n c·ªßa m·ª•c ti√™u

             -- Ki·ªÉm tra kho·∫£ng c√°ch tr√°nh l·ªói CFrame
            if (cameraPos - lookAt).Magnitude > 0.1 then
                 -- S·ª≠ d·ª•ng Lerp ƒë·ªÉ l√†m m∆∞·ª£t camera m·ªôt ch√∫t (t√πy ch·ªçn)
                 camera.CFrame = camera.CFrame:Lerp(CFrame.new(cameraPos, lookAt), 0.2) -- 0.2 l√† t·ªëc ƒë·ªô l√†m m∆∞·ª£t
                 -- Ho·∫∑c ƒë·∫∑t tr·ª±c ti·∫øp n·∫øu kh√¥ng c·∫ßn l√†m m∆∞·ª£t:
                 -- camera.CFrame = CFrame.new(cameraPos, lookAt)
            end

        else
            -- Logic nh√¨n v√†o b·ªô ph·∫≠n c≈©
            local targetPart = targetChar:FindFirstChild(bodyParts[partIndex])
            if targetPart then
                lookAt = targetPart.Position
                 -- Ki·ªÉm tra kho·∫£ng c√°ch tr√°nh l·ªói CFrame
                if (lookFrom - lookAt).Magnitude > 0.1 then
                     -- S·ª≠ d·ª•ng Lerp ƒë·ªÉ l√†m m∆∞·ª£t camera m·ªôt ch√∫t (t√πy ch·ªçn)
                    camera.CFrame = camera.CFrame:Lerp(CFrame.new(lookFrom, lookAt), 0.15) -- T·ªëc ƒë·ªô l√†m m∆∞·ª£t kh√°c nhau
                    -- Ho·∫∑c ƒë·∫∑t tr·ª±c ti·∫øp:
                    -- camera.CFrame = CFrame.new(lookFrom, lookAt)
                end
            else
                -- N·∫øu kh√¥ng th·∫•y b·ªô ph·∫≠n, nh√¨n v√†o RootPart
                lookAt = targetRoot.Position
                if (lookFrom - lookAt).Magnitude > 0.1 then
                    camera.CFrame = camera.CFrame:Lerp(CFrame.new(lookFrom, lookAt), 0.15)
                    -- camera.CFrame = CFrame.new(lookFrom, lookAt)
                end
            end
        end
    end
end

-- Bind to RenderStep
RunService:BindToRenderStep("LookFollowLoop", Enum.RenderPriority.Camera.Value + 1, CoreLoop)

-- Cleanup when GUI is destroyed
ScreenGui.Destroying:Connect(function()
    pcall(function() RunService:UnbindFromRenderStep("LookFollowLoop") end)
	resetTargetStates() -- ƒê·∫£m b·∫£o m·ªçi th·ª© ƒë∆∞·ª£c reset
    print("LookFollow GUI Destroyed and Unbound.")
end)

-- Initial setup
updateList()
print("LookFollow GUI Loaded.")
